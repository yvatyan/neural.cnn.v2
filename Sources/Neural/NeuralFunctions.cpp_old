#include "Headers\NeuralFunctions.h"
#include <cmath>

using namespace neural;

void Function::defineFunctionByPointer(double(*func) (double, Function::Control)) {
	     if(func == Activation::softMax) funcName = "softMax";
	else if(func == Activation::softStep) funcName = "softStep";
	else if(func == Activation::softPlus) funcName = "softPlus";
	else if(func == Activation::softSign) funcName = "softSign";
	else if(func == Activation::binaryStep) funcName = "binaryStep";
	else if(func == Activation::tanH) funcName = "tanH";
	else if(func == Activation::arcTan) funcName = "arcTan";
	else if(func == Activation::identity) funcName = "identity";
	else if(func == Activation::bentIdentity) funcName = "bentIdentity";
	else if(func == Activation::gaussian) funcName = "gaussian";
	
	else if(func == Combination::max) funcName = "max";
	else if(func == Combination::min) funcName = "min";
	else if(func == Combination::mean) funcName = "mean";
	else if(func == Combination::maxQty) funcName = "maxQty";
	else if(func == Combination::minQty) funcName = "minQty";
	else if(func == Combination::hdtv) funcName = "hdtv";
	else if(func == Combination::yuv) funcName = "yuv";
	else if(func == Combination::sum) funcName = "sum";
	else	funcName = "undefined";
	function = func;
}
void Function::defineFunctionByName(const std::string& name) {
	     if("softMax" == name) function = Activation::softMax;
	else if("softStep" == name) function = Activation::softStep;
	else if("softPlus" == name) function = Activation::softPlus;
	else if("softSign" == name) function = Activation::softSign;
	else if("binaryStep" == name) function = Activation::binaryStep;
	else if("tanH" == name) function = Activation::tanH;
	else if("arcTan" == name) function = Activation::arcTan;
	else if("identity" == name) function = Activation::identity;
	else if("bentIdentity" == name) function = Activation::bentIdentity;
	else if("gaussian" == name) function = Activation::gaussian;

	else if("max" == name) function = Combination::max;
	else if("min" == name) function = Combination::min;
	else if("mean" == name) function = Combination::mean;
	else if("maxQty" == name) function = Combination::maxQty;
	else if("minQty" == name) function = Combination::minQty;
	else if("hdtv" == name) function = Combination::hdtv;
	else if("yuv" == name) function = Combination::yuv;
	else if("sun" == name) function = Combination::sum;
	else 	function = NULL;

	funcName = name;
}
Function::Function(double(*func) (double, Function::Control)) {
	defineFunctionByPointer(func);
}
Function::Function(double(*func) (double, Function::Control), const std::string& setName) 
	:	funcName(setName)
{
	function = func;
}
Function::Function(const std::string& name) {
	defineFunctionByName(name);	
}
double Function::operator()(double value, Function::Control todo) const {
	assert(function);
	return function(value, todo);
}
std::string Function::Name() const {
	return funcName;
}

double Function::Activation::softMax(double value, Function::Control todo) {
	static double sum = 0;
	
	switch(todo) {
		case	Accumulate :
					sum += std::pow(M_E, value);
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return std::pow(M_E, value) / sum;
	};
	return -1;
}
double Function::Activation::softStep(double value, Function::Control todo) {
	static double sum = 0;
	static double param = 1;

	switch(todo) {
		case	Accumulate :
					sum += value;
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return 1 / (1 + std::pow(M_E, -1*param*sum);
		case	Param1 :
					param = value;
					return 0;
	};
	return -1;
}
double Function::Activation::softPlus(double value, Function::Control todo) {
	static double sum = 0;
	
	switch(todo) {
		case	Accumulate :
					sum += value;
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return std::log( std::pow(M_E, sum) + 1 );
	};
	return -1;
}
double Function::Activation::softSign(double value, Function::Control todo) {
	static double sum = 0;

	switch(todo) {
		case	Accumulate :
					sum += value;
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return sum / ( std::abs(sum) + 1 );
	};
	return -1;
}
double Function::Activation::binaryStep(double value, Function::Control todo) {
	static double sum = 0;

	switch(todo) {
		case	Accumulate :
					sum += value;
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return ( sum < 0 ? 0 : 1 ); 
	};
	return -1;
}
double Function::Activation::tanH(double value, Function::Control todo) {
	static double sum = 0;

	switch(todo) {
		case	Accumulate :
					sum += value;
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return ( 2 / (1 + std::pow(M_E, -2*sum)) ) - 1; 
	};
	return -1;
}
double Function::Activation::identity(double value, Function::Control todo) {
	return Function::Combination::sum(value, todo);
}
double Function::Activation::bentIdentity(double value, Function::Control todo) {
	static double sum = 0;

	switch(todo) {
		case	Accumulate :
					sum += value;
					return 0;
		case	Erase :
					sum = 0;
					return 0;
		case	Answer :
					return ( 2 / (1 + std::pow(M_E, -2*sum)) ) - 1; 
	};
	return -1;
}

